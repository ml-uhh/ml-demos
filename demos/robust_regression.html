<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Robust Regression (L1 Loss) — Data Coordinates [-1, 1]²</title>
  <style>
    body {
      font-family: sans-serif;
      text-align: center;
    }
    h1 {
      margin-top: 20px;
      font-size: 32px;
    }
    canvas {
      border: 1px solid #000;
      cursor: grab;
      margin-top: 10px;
      background: #fafafa;
    }
    #controls {
      margin-top: 15px;
    }
    button, label {
      font-size: 16px;
      padding: 10px 20px;
      margin: 5px;
      cursor: pointer;
    }
    input[type="checkbox"] {
      transform: scale(1.5);
      margin-right: 8px;
    }
    #info {
      font-family: sans-serif;
      margin-top: 15px;
      font-size: 18px;
    }
  </style>
</head>
<body>
  <h1>Robust Regression (L1 Loss)</h1>
  <p>Click to add points, drag to move them. Toggle lines below.</p>
  <canvas id="canvas" width="800" height="500"></canvas>
  
  <div id="legend">
  <svg width="260" height="44">
    <line x1="10" y1="12" x2="50" y2="12" stroke="red" stroke-width="4" />
    <text x="60" y="16" font-size="16">L2 Regression</text>
    <line x1="10" y1="34" x2="50" y2="34" stroke="green" stroke-width="4" />
    <text x="60" y="38" font-size="16">L1 Regression</text>
  </svg>
  </div>
  
  <div id="controls">
    <button id="resetBtn">Reset</button>
    <label><input type="checkbox" id="l2Toggle" checked />Show L2</label>
    <label><input type="checkbox" id="l1Toggle" />Show L1</label>
  </div>
  <div id="info"></div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const resetBtn = document.getElementById('resetBtn');
    const l2Toggle = document.getElementById('l2Toggle');
    const l1Toggle = document.getElementById('l1Toggle');
    const info = document.getElementById('info');
    const points = [];   // store points in DATA coordinates: x,y ∈ [-1,1]

    let draggingPoint = null;
    const radiusPx = 7;

    const width = canvas.width;
    const height = canvas.height;

    // === Coordinate transforms (same mapping as in the polynomial regression demo) ===
    function dataToPixel(x, y) {
      return [(x + 1) / 2 * width, (1 - (y + 1) / 2) * height];
    }
    function pixelToData(px, py) {
      return [px / width * 2 - 1, 1 - py / height * 2];
    }

    // Utility: find a point near a pixel position (hit test in pixel space)
    function getPointAtPixel(px, py) {
      for (const p of points) {
        const [cx, cy] = dataToPixel(p.x, p.y);
        const dx = cx - px;
        const dy = cy - py;
        if (dx * dx + dy * dy <= radiusPx * radiusPx) return p;
      }
      return null;
    }

    canvas.addEventListener('mousedown', (e) => {
      const { offsetX, offsetY } = e;
      draggingPoint = getPointAtPixel(offsetX, offsetY);
      if (!draggingPoint) {
        const [x, y] = pixelToData(offsetX, offsetY);
        points.push({ x, y });
      }
      draw();
    });

    canvas.addEventListener('mousemove', (e) => {
      if (draggingPoint) {
        const [x, y] = pixelToData(e.offsetX, e.offsetY);
        draggingPoint.x = Math.max(-1, Math.min(1, x));
        draggingPoint.y = Math.max(-1, Math.min(1, y));
        draw();
      }
    });

    canvas.addEventListener('mouseup', () => {
      draggingPoint = null;
    });

    resetBtn.addEventListener('click', () => {
      points.length = 0;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      info.textContent = '';
      draw();
    });

    l2Toggle.addEventListener('change', draw);
    l1Toggle.addEventListener('change', draw);

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // draw axis box and light grid for reference
      ctx.save();
      ctx.strokeStyle = '#ccc';
      ctx.lineWidth = 1;
      // border
      ctx.strokeRect(0.5, 0.5, width-1, height-1);
      // axes at x=0 and y=0
      const [x0px, y0px] = dataToPixel(0, 0);
      ctx.beginPath();
      ctx.moveTo(0, y0px);
      ctx.lineTo(width, y0px);
      ctx.moveTo(x0px, 0);
      ctx.lineTo(x0px, height);
      ctx.stroke();
      ctx.restore();

      // draw points
      for (const p of points) {
        const [px, py] = dataToPixel(p.x, p.y);
        ctx.beginPath();
        ctx.arc(px, py, radiusPx, 0, Math.PI * 2);
        ctx.fillStyle = 'black';
        ctx.fill();
      }

      let infoText = "";

      if (points.length >= 2) {
        if (l2Toggle.checked) {
          const l2 = linearRegression(points); // in DATA coords
          drawLine(l2.m, l2.b, 'red');
          infoText += `L2: y = ${l2.m.toFixed(3)} * x + ${l2.b.toFixed(3)}<br>`;
        }

        if (l1Toggle.checked) {
          const l1 = robustRegressionIRLS(points); // in DATA coords
          drawLine(l1.m, l1.b, 'green');
          infoText += `L1: y = ${l1.m.toFixed(3)} * x + ${l1.b.toFixed(3)}`;
        }
      }

      info.innerHTML = infoText;
    }

    // Draw a line given y = m x + b, in DATA coords, clipped to canvas edges
    function drawLine(m, b, color) {
      // endpoints at x=-1 and x=1 in DATA space
      let x1 = -1, y1 = m * x1 + b;
      let x2 =  1, y2 = m * x2 + b;

      // optional vertical clipping if needed (basic clipping to y∈[-1,1])
      function clipSegmentToBox(x1, y1, x2, y2) {
        // Liang-Barsky could be used; here a simple iterative clip to y
        const points = [];
        const addIfIn = (x, y) => { if (y >= -1 && y <= 1) points.push([x, y]); };
        addIfIn(x1, y1); addIfIn(x2, y2);

        // Intersections with y=-1 and y=1
        if (Math.abs(x2 - x1) > 1e-12) {
          const mloc = (y2 - y1) / (x2 - x1);
          const bLoc = y1 - mloc * x1;
          const xi_yneg = (-1 - bLoc) / mloc;
          const xi_ypos = ( 1 - bLoc) / mloc;
          if (xi_yneg >= -1 && xi_yneg <= 1) points.push([xi_yneg, -1]);
          if (xi_ypos >= -1 && xi_ypos <= 1) points.push([xi_ypos,  1]);
        } else {
          // vertical in data coords: x = const
          // intersect with y box
          points.push([x1, -1], [x1, 1]);
        }
        // Keep two extreme points within box
        points.sort((a,b)=>a[0]-b[0]);
        // Filter to those inside the box
        const inside = points.filter(([x,y]) => x>=-1 && x<=1 && y>=-1 && y<=1);
        if (inside.length < 2) return null;
        return [inside[0], inside[inside.length-1]];
      }

      const clipped = clipSegmentToBox(x1, y1, x2, y2);
      if (!clipped) return;
      const [[cx1, cy1], [cx2, cy2]] = clipped;
      const [p1x, p1y] = dataToPixel(cx1, cy1);
      const [p2x, p2y] = dataToPixel(cx2, cy2);

      ctx.beginPath();
      ctx.moveTo(p1x, p1y);
      ctx.lineTo(p2x, p2y);
      ctx.strokeStyle = color;
      ctx.lineWidth = 3;
      ctx.stroke();
    }

    // Ordinary least squares in DATA coords
    function linearRegression(data) {
      const n = data.length;
      const sumX = data.reduce((acc, p) => acc + p.x, 0);
      const sumY = data.reduce((acc, p) => acc + p.y, 0);
      const sumXY = data.reduce((acc, p) => acc + p.x * p.y, 0);
      const sumX2 = data.reduce((acc, p) => acc + p.x * p.x, 0);

      const meanX = sumX / n;
      const meanY = sumY / n;

      const numerator = sumXY - n * meanX * meanY;
      const denominator = sumX2 - n * meanX * meanX;

      const m = numerator / denominator;
      const b = meanY - m * meanX;

      return { m, b };
    }

    // IRLS for L1 loss in DATA coords
    function robustRegressionIRLS(data, maxIter = 100, epsilon = 1e-6) {
      let { m, b } = linearRegression(data);

      for (let iter = 0; iter < maxIter; iter++) {
        const weights = data.map(p => {
          const residual = p.y - (m * p.x + b);
          return 1 / (Math.abs(residual) + 1e-8);
        });

        let sumW = 0, sumWX = 0, sumWY = 0, sumWXX = 0, sumWXY = 0;

        for (let i = 0; i < data.length; i++) {
          const w = weights[i];
          const x = data[i].x;
          const y = data[i].y;

          sumW += w;
          sumWX += w * x;
          sumWY += w * y;
          sumWXX += w * x * x;
          sumWXY += w * x * y;
        }

        const denom = sumW * sumWXX - sumWX * sumWX;
        if (Math.abs(denom) < 1e-12) break;

        const mNew = (sumW * sumWXY - sumWX * sumWY) / denom;
        const bNew = (sumWY * sumWXX - sumWX * sumWXY) / denom;

        if (Math.abs(mNew - m) < epsilon && Math.abs(bNew - b) < epsilon) break;

        m = mNew;
        b = bNew;
      }

      return { m, b };
    }

    draw();
  </script>
</body>
</html>
