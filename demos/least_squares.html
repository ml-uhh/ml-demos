<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Least Squares Regression</title>
  <style>
    body {
      font-family: sans-serif;
      text-align: center;
    }
    h1 {
      margin-top: 20px;
      font-size: 32px;
    }
    canvas {
      border: 1px solid #000;
      cursor: crosshair; /* default: cross */
      margin-top: 10px;
      background: #fafafa;
    }
    #controls {
      margin-top: 15px;
    }
    button, label {
      font-size: 16px;
      padding: 10px 20px;
      margin: 5px;
      cursor: pointer;
    }
    input[type="checkbox"] {
      transform: scale(1.5);
      margin-right: 8px;
    }
    #info {
      font-family: sans-serif;
      margin-top: 15px;
      font-size: 18px;
    }
  </style>
</head>
<body>
  <h1>Least Squares Regression</h1>
  <p>Click to add points, drag to move them. Toggle lines below.</p>
  <canvas id="canvas" width="800" height="500"></canvas>

  <div id="controls">
    <button id="resetBtn">Clear Points</button>
    <label><input type="checkbox" id="l2Toggle" checked />Show line</label>
    <label><input type="checkbox" id="errorsToggle" />Show errors</label>
  </div>
  <div id="info"></div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const resetBtn = document.getElementById('resetBtn');
    const l2Toggle = document.getElementById('l2Toggle');
    const errorsToggle = document.getElementById('errorsToggle');
    const info = document.getElementById('info');
    const points = [];

    let draggingPoint = null;
    let hoverPoint = null;
    const radiusPx = 7;

    const width = canvas.width;
    const height = canvas.height;

    function dataToPixel(x, y) {
      return [(x + 1) / 2 * width, (1 - (y + 1) / 2) * height];
    }
    function pixelToData(px, py) {
      return [px / width * 2 - 1, 1 - py / height * 2];
    }

    function getPointAtPixel(px, py) {
      for (const p of points) {
        const [cx, cy] = dataToPixel(p.x, p.y);
        const dx = cx - px;
        const dy = cy - py;
        if (dx * dx + dy * dy <= radiusPx * radiusPx) return p;
      }
      return null;
    }

    // --- restore full-window drag tracking ---
    window.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      const offsetX = e.clientX - rect.left;
      const offsetY = e.clientY - rect.top;

      if (draggingPoint) {
        // still dragging even outside canvas
        const [x, y] = pixelToData(offsetX, offsetY);
        draggingPoint.x = Math.max(-1, Math.min(1, x));
        draggingPoint.y = Math.max(-1, Math.min(1, y));
        draw();
      } else {
        // hover detection only if inside canvas bounds
        if (
          offsetX >= 0 &&
          offsetX <= canvas.width &&
          offsetY >= 0 &&
          offsetY <= canvas.height
        ) {
          const hit = getPointAtPixel(offsetX, offsetY);
          hoverPoint = hit;
          canvas.style.cursor = hit ? 'grab' : 'crosshair';
        } else {
          hoverPoint = null;
          canvas.style.cursor = 'crosshair';
        }
        draw();
      }
    });

    window.addEventListener('mouseup', () => {
      draggingPoint = null;
      canvas.style.cursor = hoverPoint ? 'grab' : 'crosshair';
      draw();
    });

    canvas.addEventListener('mousedown', (e) => {
      const { offsetX, offsetY } = e;
      hoverPoint = getPointAtPixel(offsetX, offsetY);
      draggingPoint = hoverPoint;
      if (!draggingPoint) {
        const [x, y] = pixelToData(offsetX, offsetY);
        points.push({ x, y });
      } else {
        canvas.style.cursor = 'grabbing';
      }
      draw();
    });

    resetBtn.addEventListener('click', () => {
      points.length = 0;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      info.textContent = '';
      draw();
    });

    l2Toggle.addEventListener('change', draw);
    errorsToggle.addEventListener('change', draw);

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // border + axes
      ctx.save();
      ctx.strokeStyle = '#ccc';
      ctx.lineWidth = 1;
      ctx.strokeRect(0.5, 0.5, width - 1, height - 1);
      const [x0px, y0px] = dataToPixel(0, 0);
      ctx.beginPath();
      ctx.moveTo(0, y0px);
      ctx.lineTo(width, y0px);
      ctx.moveTo(x0px, 0);
      ctx.lineTo(x0px, height);
      ctx.stroke();
      ctx.restore();

      // points (orange when hovered or moved)
      for (const p of points) {
        const [px, py] = dataToPixel(p.x, p.y);
        ctx.beginPath();
        ctx.arc(px, py, radiusPx, 0, Math.PI * 2);
        ctx.fillStyle = (p === hoverPoint || p === draggingPoint) ? 'orange' : 'black';
        ctx.fill();
      }

      let infoText = "";

      if (points.length >= 2 && l2Toggle.checked) {
        const l2 = linearRegression(points);
        drawLine(l2.m, l2.b, 'red');
        infoText += `y = ${l2.m.toFixed(3)} * x + ${l2.b.toFixed(3)}`;

        if (errorsToggle.checked) {
          drawResiduals(l2.m, l2.b);
        }
      }

      info.innerHTML = infoText;
    }

    function drawLine(m, b, color) {
      let x1 = -1, y1 = m * x1 + b;
      let x2 = 1, y2 = m * x2 + b;

      function clipSegmentToBox(x1, y1, x2, y2) {
        const pts = [];
        const addIfIn = (x, y) => { if (y >= -1 && y <= 1) pts.push([x, y]); };
        addIfIn(x1, y1); addIfIn(x2, y2);

        if (Math.abs(x2 - x1) > 1e-12) {
          const mloc = (y2 - y1) / (x2 - x1);
          const bLoc = y1 - mloc * x1;
          const xi_yneg = (-1 - bLoc) / mloc;
          const xi_ypos = (1 - bLoc) / mloc;
          if (xi_yneg >= -1 && xi_yneg <= 1) pts.push([xi_yneg, -1]);
          if (xi_ypos >= -1 && xi_ypos <= 1) pts.push([xi_ypos, 1]);
        } else {
          pts.push([x1, -1], [x1, 1]);
        }
        pts.sort((a, b) => a[0] - b[0]);
        const inside = pts.filter(([x, y]) => x >= -1 && x <= 1 && y >= -1 && y <= 1);
        if (inside.length < 2) return null;
        return [inside[0], inside[inside.length - 1]];
      }

      const clipped = clipSegmentToBox(x1, y1, x2, y2);
      if (!clipped) return;
      const [[cx1, cy1], [cx2, cy2]] = clipped;
      const [p1x, p1y] = dataToPixel(cx1, cy1);
      const [p2x, p2y] = dataToPixel(cx2, cy2);

      ctx.beginPath();
      ctx.moveTo(p1x, p1y);
      ctx.lineTo(p2x, p2y);
      ctx.strokeStyle = color;
      ctx.lineWidth = 3;
      ctx.stroke();
    }

    function drawResiduals(m, b) {
      ctx.save();
      ctx.setLineDash([6, 6]);
      ctx.lineWidth = 2;
      ctx.strokeStyle = 'blue';

      for (const p of points) {
        const x = p.x;
        const y = p.y;
        const yhat = m * x + b;

        const y1 = Math.max(-1, Math.min(1, y));
        const y2 = Math.max(-1, Math.min(1, yhat));

        const [px1, py1] = dataToPixel(x, y1);
        const [px2, py2] = dataToPixel(x, y2);

        ctx.beginPath();
        ctx.moveTo(px1, py1);
        ctx.lineTo(px2, py2);
        ctx.stroke();
      }
      ctx.restore();
    }

    function linearRegression(data) {
      const n = data.length;
      const sumX = data.reduce((acc, p) => acc + p.x, 0);
      const sumY = data.reduce((acc, p) => acc + p.y, 0);
      const sumXY = data.reduce((acc, p) => acc + p.x * p.y, 0);
      const sumX2 = data.reduce((acc, p) => acc + p.x * p.x, 0);

      const meanX = sumX / n;
      const meanY = sumY / n;

      const numerator = sumXY - n * meanX * meanY;
      const denominator = sumX2 - n * meanX * meanX;

      const m = numerator / denominator;
      const b = meanY - m * meanX;

      return { m, b };
    }

    draw();
  </script>
</body>
</html>
