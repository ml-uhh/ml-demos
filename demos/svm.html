<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Linear SVM – Binary Classification</title>
  <style>
    body {
      font-family: sans-serif;
      text-align: center;
    }
    h1 {
      margin-top: 20px;
      font-size: 32px;
    }
    canvas {
      border: 1px solid #000;
      cursor: crosshair;
      margin-top: 10px;
      background: #fafafa;
      display: block;
      margin-left: auto;
      margin-right: auto;
    }
    #controls {
      margin-top: 15px;
      text-align: center;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
    }
    .control-row {
      margin-top: 4px;
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 16px;
      align-items: center;
    }
    button, label {
      font-size: 16px;
      padding: 4px 8px;
      cursor: pointer;
    }
    input[type="checkbox"] {
      transform: scale(1.1);
      margin-right: 6px;
    }
    input[type="radio"] {
      margin-right: 4px;
      margin-left: 6px;
    }
    input[type="range"] {
      width: 200px;
    }
    .colorDot {
      display: inline-block;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      margin-right: 6px;
      vertical-align: middle;
      border: 1px solid #00000055;
    }
    #info {
      margin-top: 15px;
      font-size: 18px;
    }
    #gradInfo {
      margin-top: 4px;
      font-size: 16px;
      font-family: monospace;
    }
  </style>
</head>
<body>
  <h1>Linear SVM – Binary Classification</h1>
  <p>
    Click to add points. Drag to move. <br/>
    Shift-click on a point to flip its class. Ctrl-click to delete.
  </p>

  <canvas id="canvas" width="800" height="500"></canvas>

  <div id="controls">
    <div class="control-row">
      <button id="resetBtn">Clear Points</button>

      <label>
        <span class="colorDot" style="background:#3498db;"></span>
        <input type="radio" name="classSel" value="blue" />
        Class -1 (blue)
      </label>

      <label>
        <span class="colorDot" style="background:#e74c3c;"></span>
        <input type="radio" name="classSel" value="red" checked />
        Class 1 (red)
      </label>
    </div>

    <div class="control-row">
      <label>
        <input type="checkbox" id="boundaryToggle" checked />
        Show decision boundary
      </label>

      <label>
        <input type="checkbox" id="violationsToggle" checked />
        Show violation lines
      </label>

      <label>
        <input type="checkbox" id="marginToggle" />
        Show margin map
      </label>
    </div>

    <div class="control-row">
      <label id="lambdaLabel" for="lambdaSlider">
        λ:
        <input type="range" id="lambdaSlider" min="-6" max="2" step="0.1" value="-2" />
        <span id="lambdaVal">1.0e-2</span>
      </label>
    </div>
  </div>

  <div id="info"></div>
  <div id="gradInfo"></div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const resetBtn = document.getElementById('resetBtn');
    const boundaryToggle = document.getElementById('boundaryToggle');
    const marginToggle = document.getElementById('marginToggle');
    const violationsToggle = document.getElementById('violationsToggle');
    const info = document.getElementById('info');
    const gradInfo = document.getElementById('gradInfo');
    const classInputs = Array.from(document.querySelectorAll('input[name="classSel"]'));

    const lambdaSlider = document.getElementById('lambdaSlider');
    const lambdaVal = document.getElementById('lambdaVal');
    const lambdaLabel = document.getElementById('lambdaLabel');

    const width = canvas.width;
    const height = canvas.height;

    const points = []; // {x, y, label: +1 or -1}
    const radiusPx = 7;

    let draggingPoint = null;
    let hoverPoint = null;

    // SVM parameters: w0 (bias b), w1, w2
    let weights = null; // {w0, w1, w2}
    let lastLoss = null;
    let lastAcc = null;
    let lastLambda = 0;
    let lastGrad = null;     // [g0, g1, g2]
    let lastIterCount = 0;
    let lastGradNorm = null;

    // Coordinate transforms
    function dataToPixel(x, y) {
      return [(x + 1) / 2 * width, (1 - (y + 1) / 2) * height];
    }

    function pixelToData(px, py) {
      return [px / width * 2 - 1, 1 - py / height * 2];
    }

    function getPointAtPixel(px, py) {
      for (const p of points) {
        const [cx, cy] = dataToPixel(p.x, p.y);
        const dx = cx - px;
        const dy = cy - py;
        if (dx * dx + dy * dy <= radiusPx * radiusPx) return p;
      }
      return null;
    }

    // --- Mouse interaction ---
    window.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      const offsetX = e.clientX - rect.left;
      const offsetY = e.clientY - rect.top;

      if (draggingPoint) {
        const [x, y] = pixelToData(offsetX, offsetY);
        draggingPoint.x = Math.max(-1, Math.min(1, x));
        draggingPoint.y = Math.max(-1, Math.min(1, y));
        fitModel();
        draw();
      } else {
        if (
          offsetX >= 0 && offsetX <= canvas.width &&
          offsetY >= 0 && offsetY <= canvas.height
        ) {
          const hit = getPointAtPixel(offsetX, offsetY);
          hoverPoint = hit;
          canvas.style.cursor = hit ? 'grab' : 'crosshair';
        } else {
          hoverPoint = null;
          canvas.style.cursor = 'crosshair';
        }
        draw();
      }
    });

    window.addEventListener('mouseup', () => {
      draggingPoint = null;
      canvas.style.cursor = hoverPoint ? 'grab' : 'crosshair';
      draw();
    });

    canvas.addEventListener('mousedown', (e) => {
      const { offsetX, offsetY, ctrlKey, metaKey, shiftKey } = e;
      const hit = getPointAtPixel(offsetX, offsetY);

      if (hit && (ctrlKey || metaKey)) {
        // delete point
        points.splice(points.indexOf(hit), 1);
        hoverPoint = null;
        fitModel();
        draw();
        return;
      }

      if (hit && shiftKey) {
        // flip class
        hit.label = -hit.label;
        fitModel();
        draw();
        return;
      }

      if (hit) {
        // drag
        hoverPoint = hit;
        draggingPoint = hit;
        canvas.style.cursor = 'grabbing';
      } else {
        // add new point
        const [x, y] = pixelToData(offsetX, offsetY);
        const clsVal = classInputs.find(i => i.checked).value;
        const label = clsVal === 'red' ? 1 : -1;
        points.push({ x, y, label });
      }

      fitModel();
      draw();
    });

    resetBtn.addEventListener('click', () => {
      points.length = 0;
      weights = null;
      lastLoss = null;
      lastAcc = null;
      lastLambda = 0;
      lastGrad = null;
      lastIterCount = 0;
      lastGradNorm = null;
      ctx.clearRect(0, 0, width, height);
      info.textContent = '';
      gradInfo.textContent = '';
      draw();
    });

    boundaryToggle.addEventListener('change', draw);
    marginToggle.addEventListener('change', draw);
    violationsToggle.addEventListener('change', draw);
    classInputs.forEach(el => el.addEventListener('change', draw));

    // Regularization controls – always enabled now
    function currentLambda() {
      const exp = parseFloat(lambdaSlider.value);
      return Math.pow(10, exp);
    }

    function updateLambdaLabel() {
      const lam = currentLambda();
      lambdaVal.textContent = lam.toExponential(1);
      lambdaLabel.style.display = 'inline-flex';
    }

    lambdaSlider.addEventListener('input', () => {
      updateLambdaLabel();
      fitModel();
      draw();
    });

    // init λ display
    updateLambdaLabel();

    // --- Smoothed (Huber) hinge SVM loss + grad + Hessian ---
    const HUBER_DELTA = 0.5;

    function computeLoss(w0, w1, w2, lam) {
      if (points.length === 0) return 0;
      let loss = 0;
      const delta = HUBER_DELTA;

      for (const p of points) {
        const yi = p.label;
        const z = w0 + w1 * p.x + w2 * p.y;
        const m = yi * z;
        const h = 1 - m;

        if (h <= 0) {
          continue;
        } else if (h >= delta) {
          loss += (h - delta / 2);
        } else {
          loss += (h * h) / (2 * delta);
        }
      }

      const baseLoss = loss / points.length;
      const regTerm = 0.5 * lam * (w1 * w1 + w2 * w2);
      return baseLoss + regTerm;
    }

    function computeLossGradHess(w0, w1, w2, lam) {
      const n = points.length;
      if (n === 0) {
        return {
          loss: 0,
          grad: [0, 0, 0],
          H: [[0, 0, 0], [0, 0, 0], [0, 0, 0]]
        };
      }

      let loss = 0;
      let g0 = 0, g1 = 0, g2 = 0;
      let H = [
        [0, 0, 0],
        [0, 0, 0],
        [0, 0, 0]
      ];

      const delta = HUBER_DELTA;

      for (const p of points) {
        const yi = p.label; // ±1
        const x0 = 1;
        const x1 = p.x;
        const x2 = p.y;

        const z = w0 + w1 * x1 + w2 * x2;
        const m = yi * z;
        const h = 1 - m; // > 0 if inside loss

        if (h <= 0) {
          continue;
        }

        if (h >= delta) {
          // linear region
          loss += (h - delta / 2);

          const scale = -yi;
          g0 += scale * x0;
          g1 += scale * x1;
          g2 += scale * x2;

        } else {
          // quadratic region
          loss += (h * h) / (2 * delta);

          const scale = -(h / delta) * yi;
          g0 += scale * x0;
          g1 += scale * x1;
          g2 += scale * x2;

          const c = 1 / delta;
          H[0][0] += c * x0 * x0;
          H[0][1] += c * x0 * x1;
          H[0][2] += c * x0 * x2;
          H[1][0] += c * x1 * x0;
          H[1][1] += c * x1 * x1;
          H[1][2] += c * x1 * x2;
          H[2][0] += c * x2 * x0;
          H[2][1] += c * x2 * x1;
          H[2][2] += c * x2 * x2;
        }
      }

      const baseLoss = loss / n;

      // average gradient
      g0 /= n;
      g1 /= n;
      g2 /= n;

      // average Hessian
      for (let i = 0; i < 3; i++) {
        for (let j = 0; j < 3; j++) {
          H[i][j] /= n;
        }
      }

      // L2 regularization on w1, w2 (not on bias)
      g1 += lam * w1;
      g2 += lam * w2;
      H[1][1] += lam;
      H[2][2] += lam;

      const eps = 1e-6;
      H[0][0] += eps;
      H[1][1] += eps;
      H[2][2] += eps;

      const regTerm = 0.5 * lam * (w1 * w1 + w2 * w2);
      const totalLoss = baseLoss + regTerm;

      return {
        loss: totalLoss,
        grad: [g0, g1, g2],
        H
      };
    }

    // Solve 3x3 linear system A x = b (Gaussian elimination)
    function solve3x3(A, b) {
      const M = [
        [A[0][0], A[0][1], A[0][2], b[0]],
        [A[1][0], A[1][1], A[1][2], b[1]],
        [A[2][0], A[2][1], A[2][2], b[2]]
      ];

      const n = 3;
      for (let i = 0; i < n; i++) {
        let maxRow = i;
        for (let k = i + 1; k < n; k++) {
          if (Math.abs(M[k][i]) > Math.abs(M[maxRow][i])) {
            maxRow = k;
          }
        }
        if (Math.abs(M[maxRow][i]) < 1e-12) {
          return null; // singular
        }
        if (maxRow !== i) {
          const tmp = M[i];
          M[i] = M[maxRow];
          M[maxRow] = tmp;
        }

        for (let k = i + 1; k < n; k++) {
          const factor = M[k][i] / M[i][i];
          for (let j = i; j <= n; j++) {
            M[k][j] -= factor * M[i][j];
          }
        }
      }

      const x = [0, 0, 0];
      for (let i = n - 1; i >= 0; i--) {
        let sum = M[i][n];
        for (let j = i + 1; j < n; j++) {
          sum -= M[i][j] * x[j];
        }
        x[i] = sum / M[i][i];
      }
      return x;
    }

    // Newton + backtracking line search
    function fitModel() {
      if (points.length < 2) {
        weights = null;
        lastLoss = null;
        lastAcc = null;
        lastGrad = null;
        lastIterCount = 0;
        lastGradNorm = null;
        return;
      }

      const hasPos = points.some(p => p.label === 1);
      const hasNeg = points.some(p => p.label === -1);
      if (!hasPos || !hasNeg) {
        weights = null;
        lastLoss = null;
        lastAcc = null;
        lastGrad = null;
        lastIterCount = 0;
        lastGradNorm = null;
        return;
      }

      const lam = currentLambda();
      lastLambda = lam;

      let w0 = 0, w1 = 0, w2 = 0;
      if (weights) {
        w0 = weights.w0;
        w1 = weights.w1;
        w2 = weights.w2;
      }

      const maxIter = 40;
      const gradTol = 1e-6;
      const stepTol = 1e-10;
      let lossRes = computeLossGradHess(w0, w1, w2, lam);

      lastIterCount = 0;
      lastGradNorm = null;

      for (let iter = 0; iter < maxIter; iter++) {
        const g = lossRes.grad;
        const H = lossRes.H;

        const gNorm = Math.sqrt(g[0]*g[0] + g[1]*g[1] + g[2]*g[2]);
        lastGradNorm = gNorm;
        lastIterCount = iter + 1;

        if (gNorm < gradTol) {
          break;
        }

        const d = solve3x3(H, g);
        if (!d) {
          break;
        }

        const stepNorm = Math.sqrt(d[0]*d[0] + d[1]*d[1] + d[2]*d[2]);
        if (stepNorm < stepTol) {
          break;
        }

        const origLoss = lossRes.loss;
        const gTd = g[0]*d[0] + g[1]*d[1] + g[2]*d[2];

        let alpha = 1.0;
        const beta = 0.5;
        const c = 1e-4;

        let newLoss;
        while (true) {
          const w0t = w0 - alpha * d[0];
          const w1t = w1 - alpha * d[1];
          const w2t = w2 - alpha * d[2];
          newLoss = computeLoss(w0t, w1t, w2t, lam);

          if (newLoss <= origLoss - c * alpha * gTd || alpha < 1e-6) {
            break;
          }
          alpha *= beta;
        }

        if (alpha < 1e-6) {
          break;
        }

        w0 = w0 - alpha * d[0];
        w1 = w1 - alpha * d[1];
        w2 = w2 - alpha * d[2];

        lossRes = computeLossGradHess(w0, w1, w2, lam);
      }

      weights = { w0, w1, w2 };
      lastLoss = lossRes.loss;
      lastGrad = lossRes.grad.slice();

      let correct = 0;
      for (const p of points) {
        const z = w0 + w1 * p.x + w2 * p.y;
        const pred = z >= 0 ? 1 : -1;
        if (pred === p.label) correct++;
      }
      lastAcc = correct / points.length;
    }

    // --- Drawing helpers ---
    function drawAxes() {
      ctx.save();
      ctx.strokeStyle = '#ccc';
      ctx.lineWidth = 1;
      ctx.strokeRect(0.5, 0.5, width - 1, height - 1);
      const [x0px, y0px] = dataToPixel(0, 0);
      ctx.beginPath();
      ctx.moveTo(0, y0px);
      ctx.lineTo(width, y0px);
      ctx.moveTo(x0px, 0);
      ctx.lineTo(x0px, height);
      ctx.stroke();
      ctx.restore();
    }

    function drawPoints() {
      if (!weights) {
        for (const p of points) {
          const [px, py] = dataToPixel(p.x, p.y);
          ctx.beginPath();
          ctx.arc(px, py, radiusPx, 0, 2 * Math.PI);
          ctx.fillStyle = (p.label === 1) ? '#e74c3c' : '#3498db';
          ctx.fill();
          ctx.lineWidth = (p === hoverPoint || p === draggingPoint) ? 3 : 1.5;
          ctx.strokeStyle = '#000000aa';
          ctx.stroke();
        }
        return;
      }

      const { w0, w1, w2 } = weights;

      for (const p of points) {
        const [px, py] = dataToPixel(p.x, p.y);
        const yi = p.label;
        const margin = yi * (w0 + w1 * p.x + w2 * p.y);

        ctx.beginPath();
        ctx.arc(px, py, radiusPx, 0, 2 * Math.PI);

        ctx.fillStyle = (p.label === 1) ? '#e74c3c' : '#3498db';
        ctx.fill();

        const isSupport = (margin <= 1 + 1e-3);
        ctx.lineWidth = (p === hoverPoint || p === draggingPoint || isSupport) ? 3 : 1.5;
        ctx.strokeStyle = isSupport ? '#000000' : '#000000aa';
        ctx.stroke();
      }
    }

    function drawDecisionBoundary() {
      if (!weights || !boundaryToggle.checked) return;

      const { w0, w1, w2 } = weights;
      const normW = Math.sqrt(w1 * w1 + w2 * w2);
      if (normW < 1e-6) return;

      function drawLevel(c, style, width) {
        const bEff = w0 - c;
        let pts = [];

        if (Math.abs(w2) > 1e-6) {
          const candidates = [];

          let x = -1;
          let y = -(bEff + w1 * x) / w2;
          candidates.push([x, y]);

          x = 1;
          y = -(bEff + w1 * x) / w2;
          candidates.push([x, y]);

          let yFix = -1;
          if (Math.abs(w1) > 1e-6) {
            let x2 = -(bEff + w2 * yFix) / w1;
            candidates.push([x2, yFix]);
          }

          yFix = 1;
          if (Math.abs(w1) > 1e-6) {
            let x2 = -(bEff + w2 * yFix) / w1;
            candidates.push([x2, yFix]);
          }

          pts = candidates.filter(([xx, yy]) =>
            xx >= -1 && xx <= 1 && yy >= -1 && yy <= 1
          );

          if (pts.length < 2) return;

          let bestI = 0, bestJ = 1, bestD = -1;
          for (let i = 0; i < pts.length; i++) {
            for (let j = i + 1; j < pts.length; j++) {
              const dx = pts[i][0] - pts[j][0];
              const dy = pts[i][1] - pts[j][1];
              const d = dx * dx + dy * dy;
              if (d > bestD) {
                bestD = d;
                bestI = i;
                bestJ = j;
              }
            }
          }

          const [x1, y1] = pts[bestI];
          const [x2, y2] = pts[bestJ];
          const [p1x, p1y] = dataToPixel(x1, y1);
          const [p2x, p2y] = dataToPixel(x2, y2);

          ctx.beginPath();
          ctx.moveTo(p1x, p1y);
          ctx.lineTo(p2x, p2y);
        } else if (Math.abs(w1) > 1e-6) {
          const x = -bEff / w1;
          if (x < -1 || x > 1) return;
          const [p1x, p1y] = dataToPixel(x, -1);
          const [p2x, p2y] = dataToPixel(x, 1);
          ctx.beginPath();
          ctx.moveTo(p1x, p1y);
          ctx.lineTo(p2x, p2y);
        } else {
          return;
        }

        ctx.strokeStyle = style;
        ctx.lineWidth = width;
        ctx.stroke();
      }

      // main decision boundary and margins
      drawLevel(0, 'black', 3);
      drawLevel(1, '#777', 1.5);
      drawLevel(-1, '#777', 1.5);
    }

    // draw dotted lines for margin-violating or misclassified points
    function drawViolationLines() {
      if (!weights || !violationsToggle.checked) return;

      const { w0, w1, w2 } = weights;
      const normSq = w1 * w1 + w2 * w2;
      if (normSq < 1e-6) return;

      for (const p of points) {
        const f = w0 + w1 * p.x + w2 * p.y;   // decision value
        const margin = p.label * f;           // y * f(x)

        // only points inside the margin or misclassified: y f(x) < 1
        if (margin >= 1 - 1e-3) continue;

        // project onto the *class margin* hyperplane y (w·x + b) = 1
        // alpha = (margin - 1) / ||w||^2, x_proj = x - alpha * y * w
        const alpha = (margin - 1) / normSq;
        const projX = p.x - alpha * p.label * w1;
        const projY = p.y - alpha * p.label * w2;

        const [px1, py1] = dataToPixel(p.x, p.y);
        const [px2, py2] = dataToPixel(projX, projY);

        ctx.save();
        ctx.beginPath();
        ctx.setLineDash([5, 4]);
        ctx.moveTo(px1, py1);
        ctx.lineTo(px2, py2);
        ctx.strokeStyle = '#00000099';
        ctx.lineWidth = 1.5;
        ctx.stroke();
        ctx.restore();
      }
    }

    function drawMarginMap() {
      if (!weights || !marginToggle.checked) return;

      const { w0, w1, w2 } = weights;
      const step = 4;

      ctx.save();
      ctx.globalAlpha = 0.85;

      for (let py = 0; py < height; py += step) {
        for (let px = 0; px < width; px += step) {
          const [x, y] = pixelToData(px + step / 2, py + step / 2);
          const z = w0 + w1 * x + w2 * y;

          const conf = Math.min(1, Math.abs(z));
          let color;
          if (z >= 0) {
            color = `rgba(231, 76, 60, ${0.08 + 0.25 * conf})`;
          } else {
            color = `rgba(52, 152, 219, ${0.08 + 0.25 * conf})`;
          }

          ctx.fillStyle = color;
          ctx.fillRect(px, py, step, step);
        }
      }

      ctx.restore();
    }

    function draw() {
      ctx.clearRect(0, 0, width, height);
      drawMarginMap();
      drawAxes();
      drawPoints();
      drawDecisionBoundary();
      drawViolationLines(); // dotted lines to the margin hyperplanes

      const reds = points.filter(p => p.label === 1).length;
      const blues = points.filter(p => p.label === -1).length;

      let text = `Class -1 (blue): ${blues}, Class 1 (red): ${reds}`;
      info.textContent = text;

      if (weights && lastGrad) {
        const { w0, w1, w2 } = weights;
        const [g0, g1, g2] = lastGrad;
        gradInfo.textContent =
          `(w, b) = (${w1.toFixed(3)}, ${w2.toFixed(3)}, ${w0.toFixed(3)})`;
      } else {
        gradInfo.textContent = '';
      }
    }

    // initial draw
    draw();
  </script>
</body>
</html>
